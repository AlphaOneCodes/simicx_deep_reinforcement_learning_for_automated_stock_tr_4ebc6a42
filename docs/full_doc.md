# Project Documentation

**Author**: SimicX AI Quant  
**Copyright**: (C) 2025-2026 SimicX. All rights reserved.  
**Generated**: 2026-01-04 13:24

## Overview

This project implements a high-fidelity quantitative trading framework designed for systematic alpha generation, hyperparameter optimization, and rigorous backtesting. The system is engineered to facilitate a seamless transition from model training to out-of-sample execution, specifically targeting the post-2025 trading environment. By utilizing a phased approach, the framework enables rapid prototyping on limited ticker sets before scaling to full-market simulations, ensuring that trading strategies are both statistically significant and computationally efficient.

The methodology is centered on "Alpha Engineering" principles to ensure institutional-grade reliability. This includes a vectorized iterative architecture that processes multi-year datasets without lookahead bias, strictly separating predictive signal generation from future price knowledge. To ensure execution realism, the system avoids "close-price" fallacies by simulating trades at next-day opening prices or intraday mid-prices. Furthermore, the framework incorporates hardware-aware acceleration, automatically leveraging Metal Performance Shaders (MPS) for Apple Silicon or CUDA for NVIDIA GPUs to optimize deep learning and mathematical workloads.

The expected outputs of this project include a comprehensive trading registry covering the full backtest duration, a validated set of optimized hyperparameters, and detailed performance metrics. The system maintains strict risk management constraints, including a non-leveraged $1,000,000 capital base and cash-aware position sizing. Every simulation produces a standardized artifact suite, including a signal sheet for the 2025 out-of-sample period and a serialized best-parameter configuration for reproducible strategy deployment.

## Implementation Plan

### Progress
- Total: 0 | Done: 0 | In Progress: 0 | Failed: 0

### Verification Order
The following files will be executed (in order) to verify the generated code works:
`tune.py --phase limited -> main.py`

### Files
| Status | Verified | File | Description | Dependencies |
|--------|----------|------|-------------|--------------|






## API Reference

### `main.py`

> **Import**: `from main import ...`

> Production entry point for DRL Trading System signal generation.

This module provides the main entry point for generating trading signals
on unseen market data using a trained DRL agent. It orchestrates the full
production pipeline including signal generation, trade simulation, and
result persistence.

The pipeline:
1. Loads trained agent parameters from best_params.json
2. Fetches trading data for the specified phase (limited/full)
3. Generates trading signals using the DRL agent
4. Runs trading simulation to compute P&L
5. Saves trading sheet and P&L results to disk

Usage:
    python main.py --phase limited
    python main.py --phase full


**`_import_signal_gen`**
```python
def _import_signal_gen()
```
> Lazy import of signal_gen module.

**`_import_data_loader`**
```python
def _import_data_loader()
```
> Lazy import of data_loader module.

**`_import_trading_sim`**
```python
def _import_trading_sim()
```
> Lazy import of trading_sim module.

**`load_best_params`**
```python
def load_best_params(params_path: str = 'best_params.json') -> Dict[str, Any]
```
> Load best parameters from JSON file.

Loads the saved hyperparameters and model path from the JSON file
generated by the tuning process.

Args:
    params_path: Path to the best_params.json file
    
Returns:
    Dictionary containing the best parameters with keys:
        - agent_type: Type of agent ('ppo', 'a2c', 'ddpg')
        - model_path: Path to saved model weights
        - turbulence_params: Dict with mu, sigma, threshold
        - h_max: Maximum shares per trade
        - technical_params: Technical indicator parameters
    
Raises:
    FileNotFoundError: If best_params.json doesn't exist
    json.JSONDecodeError: If the file is not valid JSON
    
Example:
    >>> import tempfile
    >>> with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
    ...     json.dump({"agent_type": "ppo", "model_path": "agent.pth",
    ...                "turbulence_params": {"threshold": 140.0},
    ...                "h_max": 100, "technical_params": {}}, f)
    ...     tmp_path = f.name
    >>> params = load_best_params(tmp_path)
    >>> params["agent_type"]
    'ppo'
    >>> params["h_max"]
    100
    >>> os.unlink(tmp_path)

**`get_tickers_for_phase`**
```python
def get_tickers_for_phase(phase: str) -> List[str]
```
> Get ticker list based on phase.

Retrieves the appropriate ticker list from the configuration
based on the specified phase.

Args:
    phase: 'limited' or 'full'
    
Returns:
    List of ticker symbols (30 tickers for full phase)
    
Example:
    >>> # Assuming simicx/alpha_config.json exists
    >>> tickers = get_tickers_for_phase("full")  # doctest: +SKIP
    >>> len(tickers)  # doctest: +SKIP
    30

**`run_production_pipeline`**
```python
def run_production_pipeline(phase: str = 'limited') -> Dict[str, Any]
```
> Run the production trading pipeline.

Orchestrates the full production pipeline:
1. Loads best parameters from best_params.json
2. Loads trading data for the specified phase
3. Generates trading signals using the trained agent
4. Runs trading simulation
5. Saves results to disk

Args:
    phase: 'limited' or 'full' ticker set (default: 'limited')
    
Returns:
    Dict containing:
        - pnl: Final P&L value (float)
        - metrics: Performance metrics dictionary
        - trading_sheet_path: Path to saved trading sheet CSV
        - pnl_results_path: Path to saved P&L results CSV
        
Raises:
    FileNotFoundError: If best_params.json or model weights not found
    ValueError: If data or parameters are invalid
    
Example:
    >>> # Requires best_params.json, database, and trained model
    >>> result = run_production_pipeline(phase="limited")  # doctest: +SKIP
    >>> "pnl" in result  # doctest: +SKIP
    True
    >>> result["trading_sheet_path"]  # doctest: +SKIP
    'trading_sheet.csv'

**`main`**
```python
def main() -> int
```
> Main entry point with CLI argument parsing.

Parses command line arguments and runs the production pipeline.

Returns:
    Exit code (0 for success, 1 for error)

**`simicx_test_load_best_params`**
```python
def simicx_test_load_best_params()
```
> Test parameter loading from JSON file.

**`simicx_test_get_tickers_for_phase`**
```python
def simicx_test_get_tickers_for_phase()
```
> Test ticker selection based on phase.

**`simicx_test_integration_with_signal_gen`**
```python
def simicx_test_integration_with_signal_gen()
```
> Integration test exercising the main pipeline interfaces.

This test validates the interface between main.py and its dependencies:
- signal_gen.py: signal_gen function, load_config
- simicx/data_loader.py: get_trading_data
- simicx/trading_sim.py: trading_sim, generate_performance_report

Note: This test requires:
1. best_params.json file
2. Database connection (for get_trading_data)
3. Trained model weights

---

### `signal_gen.py`

> **Import**: `from signal_gen import ...`

> 
Signal Generation Module for DRL Trading System.

This module provides:
- Hardware device detection (CUDA, MPS, CPU)
- Feature engineering with technical indicators (MACD, RSI, CCI, ADX)
- Turbulence calculation for risk management
- DRL Agent implementations (PPO, A2C, DDPG)
- Day-by-day signal generation loop with virtual portfolio simulation


**`get_device`**
```python
def get_device() -> torch.device
```
> Get the best available device for PyTorch computation.

Checks for hardware availability in order: CUDA -> MPS -> CPU.

Returns:
    torch.device: The best available device.
    
Example:
    >>> device = get_device()
    >>> model = model.to(device)
    >>> print(device.type)  # 'cuda', 'mps', or 'cpu'

**`calc_features`**
```python
def calc_features(ohlcv_df: pd.DataFrame, tickers: List[str]) -> pd.DataFrame
```
> Calculate technical indicators for feature engineering.

Computes MACD (12, 26, 9), RSI (14), CCI (14), and ADX (14) for each ticker.
NaN values are handled using bfill then ffill, with sensible defaults for
any remaining NaNs.

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, open, high, low, close, volume]
    tickers: List of ticker symbols to process
    
Returns:
    pd.DataFrame: DataFrame indexed by time with columns for each indicator per ticker:
        - {ticker}_macd: MACD line value
        - {ticker}_rsi: RSI indicator (0-100)
        - {ticker}_cci: Commodity Channel Index
        - {ticker}_adx: Average Directional Index (0-100)
        
Example:
    >>> ohlcv = pd.DataFrame({
    ...     'time': pd.date_range('2024-01-01', periods=50),
    ...     'ticker': ['AAPL'] * 50,
    ...     'open': np.random.rand(50) * 100,
    ...     'high': np.random.rand(50) * 100,
    ...     'low': np.random.rand(50) * 100,
    ...     'close': np.random.rand(50) * 100,
    ...     'volume': np.random.randint(1000, 10000, 50)
    ... })
    >>> features = calc_features(ohlcv, ['AAPL'])
    >>> 'AAPL_macd' in features.columns
    True

**`calc_turbulence`**
```python
def calc_turbulence(ohlcv_df: pd.DataFrame, tickers: List[str], lookback: int = 252) -> pd.Series
```
> Calculate turbulence index for risk management.

Turbulence measures how unusual current market conditions are compared
to historical patterns using Mahalanobis distance.

Formula: d_t = (y_t - μ) Σ^{-1} (y_t - μ)^T

Where:
    - y_t: Daily returns vector at time t
    - μ: Mean of historical returns over lookback period
    - Σ: Covariance matrix of historical returns

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, open, high, low, close, volume]
    tickers: List of ticker symbols
    lookback: Historical lookback period for calculating μ and Σ (default: 252 trading days)
    
Returns:
    pd.Series: Turbulence index values indexed by time
    
Example:
    >>> turbulence = calc_turbulence(ohlcv_df, tickers=['AAPL', 'MSFT'], lookback=252)
    >>> if turbulence.iloc[-1] > 140:
    ...     print("High turbulence - entering risk-off mode")

**class `BaseAgent`**
```python
class BaseAgent(nn.Module):
```
> Base DRL Agent with shared architecture for trading.

Architecture:
    Shared: Linear(181->256) -> ReLU -> Linear(256->128) -> ReLU
    Actor Head: Linear(128->30) -> Tanh (outputs actions in [-1, 1])
    Critic Head: Linear(128->1) (outputs state value)

The agent uses an actor-critic architecture suitable for PPO, A2C, and DDPG
algorithms. The shared layers learn representations, while the actor head
outputs continuous actions and the critic head estimates state values.

Attributes:
    state_dim: Input state dimension (default: 181)
    action_dim: Output action dimension (default: 30)
    device: Computation device (auto-detected)
    
Example:
    >>> agent = BaseAgent(state_dim=181, action_dim=30)
    >>> state = torch.randn(1, 181)
    >>> action, value = agent(state.to(agent.device))
    >>> action.shape
    torch.Size([1, 30])
    >>> # For inference
    >>> action_np = agent.get_action(state.squeeze().numpy())
    >>> action_np.shape
    (30,)

**`BaseAgent.__init__`**
```python
def __init__(self, state_dim: int = STATE_DIM, action_dim: int = ACTION_DIM, hidden1: int = 256, hidden2: int = 128, device: Optional[torch.device] = None)
```
> Initialize the base agent.

Args:
    state_dim: State space dimension (default: 181)
    action_dim: Action space dimension (default: 30)
    hidden1: First hidden layer size (default: 256)
    hidden2: Second hidden layer size (default: 128)
    device: Computation device (default: auto-detect)

**`BaseAgent.forward`**
```python
def forward(self, state: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]
```
> Forward pass through the network.

Args:
    state: Input state tensor of shape (batch, state_dim)
    
Returns:
    Tuple of:
        - action: Action tensor of shape (batch, action_dim) in range [-1, 1]
        - value: State value tensor of shape (batch, 1)

**`BaseAgent.get_action`**
```python
def get_action(self, state: Union[np.ndarray, torch.Tensor]) -> np.ndarray
```
> Get action from state for inference (no gradient computation).

Args:
    state: State vector of shape (state_dim,) or (batch, state_dim)
    
Returns:
    np.ndarray: Action vector of shape (action_dim,) in range [-1, 1]
    
Example:
    >>> agent = BaseAgent()
    >>> state = np.random.randn(181).astype(np.float32)
    >>> action = agent.get_action(state)
    >>> action.shape
    (30,)
    >>> np.all((action >= -1) & (action <= 1))
    True

**`BaseAgent.load_weights`**
```python
def load_weights(self, path: str) -> None
```
> Load model weights from a checkpoint file.

The checkpoint file must contain a 'state_dict' key with the
PyTorch model state dictionary.

Args:
    path: Path to the .pth checkpoint file
    
Raises:
    FileNotFoundError: If the checkpoint file doesn't exist
    KeyError: If 'state_dict' key is not found in checkpoint
    
Example:
    >>> agent = BaseAgent()
    >>> agent.load_weights('best_agent.pth')

**class `PPOAgent`**
```python
class PPOAgent(BaseAgent):
```
> Proximal Policy Optimization (PPO) Agent.

Inherits from BaseAgent with PPO-specific initialization.
Uses the same network architecture as BaseAgent.

**`PPOAgent.__init__`**
```python
def __init__(self, *args, **kwargs)
```
**class `A2CAgent`**
```python
class A2CAgent(BaseAgent):
```
> Advantage Actor-Critic (A2C) Agent.

Inherits from BaseAgent with A2C-specific initialization.
Uses the same network architecture as BaseAgent.

**`A2CAgent.__init__`**
```python
def __init__(self, *args, **kwargs)
```
**class `DDPGAgent`**
```python
class DDPGAgent(BaseAgent):
```
> Deep Deterministic Policy Gradient (DDPG) Agent.

Inherits from BaseAgent with DDPG-specific initialization.
Uses the same network architecture as BaseAgent.

**`DDPGAgent.__init__`**
```python
def __init__(self, *args, **kwargs)
```
**`construct_state`**
```python
def construct_state(balance: float, prices: np.ndarray, holdings: np.ndarray, macd: np.ndarray, rsi: np.ndarray, cci: np.ndarray, adx: np.ndarray) -> np.ndarray
```
> Construct the state vector for the DRL agent.

State space: s_t = [b_t, p_t, h_t, M_t, R_t, C_t, X_t]
Total dimensions: 1 + 30 + 30 + 30 + 30 + 30 + 30 = 181

Args:
    balance: Current cash balance (scalar)
    prices: Stock prices array of shape (30,)
    holdings: Holdings array of shape (30,)
    macd: MACD indicator values of shape (30,)
    rsi: RSI indicator values of shape (30,)
    cci: CCI indicator values of shape (30,)
    adx: ADX indicator values of shape (30,)
    
Returns:
    np.ndarray: State vector of shape (181,) as float32
    
Example:
    >>> state = construct_state(
    ...     balance=1000000,
    ...     prices=np.ones(30) * 100,
    ...     holdings=np.zeros(30),
    ...     macd=np.zeros(30),
    ...     rsi=np.ones(30) * 50,
    ...     cci=np.zeros(30),
    ...     adx=np.ones(30) * 25
    ... )
    >>> state.shape
    (181,)
    >>> state[0]  # Balance
    1000000.0

**`signal_gen`**
```python
def signal_gen(ohlcv_df: pd.DataFrame, agent_path: str = 'best_agent.pth', agent_type: str = 'PPO', turbulence_threshold: float = 140.0, h_max: int = 100, initial_cash: float = 1000000.0, tickers: Optional[List[str]] = None, **kwargs) -> pd.DataFrame
```
> Generate trading signals by simulating a virtual trading environment day-by-day.

This function iterates through each trading day, calculates the current state,
checks turbulence for risk management, and generates actions using the DRL agent.

CRITICAL: Actions at time T are based ONLY on data available at time T.
No future data is used. Execution happens at T+1 open (handled by simulation logic).

The virtual environment maintains cash and holdings state to ensure realistic
signal generation that respects position constraints.

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, open, high, low, close, volume]
    agent_path: Path to the trained agent weights file (default: 'best_agent.pth')
    agent_type: Type of agent - 'PPO', 'A2C', or 'DDPG' (default: 'PPO')
    turbulence_threshold: Threshold for turbulence-based risk-off mode (default: 140.0)
    h_max: Maximum number of shares per trade action (default: 100)
    initial_cash: Starting cash balance (default: 1000000.0)
    tickers: List of 30 ticker symbols (default: derived from ohlcv_df)
    **kwargs: Additional parameters for compatibility
    
Returns:
    pd.DataFrame: Signal DataFrame with columns [time, ticker, action, quantity]
        - time: Trading date (datetime)
        - ticker: Stock ticker symbol (str)
        - action: 'BUY' or 'SELL' (str)
        - quantity: Number of shares (int, non-negative)
        
Example:
    >>> from simicx.data_loader import get_trading_data
    >>> ohlcv = get_trading_data()
    >>> signals = signal_gen(
    ...     ohlcv,
    ...     agent_path='best_agent.pth',
    ...     agent_type='PPO',
    ...     turbulence_threshold=140.0,
    ...     h_max=100
    ... )
    >>> signals.columns.tolist()
    ['time', 'ticker', 'action', 'quantity']
    >>> signals['action'].isin(['BUY', 'SELL']).all()
    True
    
Note:
    - Requires exactly 30 tickers for the 181-dimensional state space
    - If turbulence exceeds threshold, all positions are sold (risk-off mode)
    - Trades are constrained by available cash (buy) and holdings (sell)
    - The agent weights must be loaded for proper inference

**`load_config`**
```python
def load_config(config_path: str = 'simicx/alpha_config.json') -> Dict
```
> Load configuration from JSON file.

Args:
    config_path: Path to the configuration file
    
Returns:
    Dict: Configuration dictionary with keys like:
        - LIMITED_TICKERS: List of limited ticker symbols
        - FULL_TICKERS: List of full ticker symbols
        - TRAINING_END_DATE: Training end date string
        - TRADING_START_DATE: Trading start date string
    
Raises:
    FileNotFoundError: If config file doesn't exist
    
Example:
    >>> config = load_config('simicx/alpha_config.json')
    >>> tickers = config['FULL_TICKERS']
    >>> len(tickers)
    30

**`simicx_test_get_device`**
```python
def simicx_test_get_device()
```
> Test device detection function.

**`simicx_test_base_agent_and_variants`**
```python
def simicx_test_base_agent_and_variants()
```
> Test BaseAgent initialization, forward pass, weight loading, and variants.

**`simicx_test_calc_features_and_turbulence`**
```python
def simicx_test_calc_features_and_turbulence()
```
> Test feature calculation and turbulence with synthetic data.

**`simicx_test_signal_gen_comprehensive`**
```python
def simicx_test_signal_gen_comprehensive()
```
> Test signal generation with synthetic data.

---

### `simicx/data_loader.py`

> **Import**: `from simicx.data_loader import ...`

> 
SimicX Data Loader Module (Database Version)

Author: SimicX
Copyright: SimicX 2024
License: SimicX XTT

Centralized OHLCV data loading from MongoDB with strict temporal controls
for alpha discovery and backtesting.

Key Features:
- Strict train/test split: Training ≤ 2024-12-31, Trading ≥ 2025-01-01
- Date alignment across tickers (consistent coverage)
- 2-phase testing support: LIMITED → FULL tickers
- Multi-asset extensibility (not equity-specific)

Usage:
    from data_loader import get_training_data, get_trading_data
    
    # For tune.py (hyperparameter optimization)
    train_df = get_training_data(LIMITED_TICKERS, years_back=3)
    
    # For main.py (backtesting)
    trade_df = get_trading_data(FULL_TICKERS)


**`get_mongo_client`**
```python
def get_mongo_client() -> MongoClient
```
> Get or create MongoDB client connection (thread-safe singleton).

Returns:
    MongoClient instance with connection pooling.

Raises:
    RuntimeError: If connection to MongoDB fails (Fail Fast).

Example:
    >>> client = get_mongo_client()
    >>> db = client[MONGODB_DATABASE]

**`get_collection`**
```python
def get_collection()
```
> Get OHLCV collection instance.

Returns:
    MongoDB collection for OHLCV data.

**`get_tickers`**
```python
def get_tickers() -> List[str]
```
> Get list of unique ticker symbols available in the database.

Returns:
    List[str]: Sorted list of available ticker symbols.

Example:
    >>> tickers = get_tickers()
    >>> print(f"Found {len(tickers)} tickers")
    >>> 'SPY' in tickers
    True

**`get_date_range`**
```python
def get_date_range(ticker: str) -> Tuple[datetime, datetime]
```
> Get the date range (start and end dates) for a specific ticker.

Args:
    ticker: Stock ticker symbol (e.g., 'SPY', 'AAPL').

Returns:
    Tuple[datetime, datetime]: (start_date, end_date) for the ticker.

Raises:
    ValueError: If the ticker is not found in the database.

Example:
    >>> start, end = get_date_range('SPY')
    >>> print(f"SPY data: {start.date()} to {end.date()}")

**`get_data`**
```python
def get_data(ticker: Optional[str] = None, tickers: Optional[List[str]] = None, phase: Optional[str] = None, start_date: Optional[str] = None, end_date: Optional[str] = None, align_dates: bool = True) -> pd.DataFrame
```
> Get OHLCV data with optional filtering by ticker(s), phase, and date range.

Args:
    ticker: Single ticker symbol (e.g., 'SPY'). Mutually exclusive with tickers/phase.
    tickers: List of ticker symbols. Mutually exclusive with ticker/phase.
    phase: 'limited' (LIMITED_TICKERS) or 'full' (FULL_TICKERS). Overrides ticker/tickers.
    start_date: Start date (inclusive) in 'YYYY-MM-DD' format.
    end_date: End date (inclusive) in 'YYYY-MM-DD' format.
    align_dates: If True, only return dates where ALL tickers have data.

Returns:
    pd.DataFrame: OHLCV data with columns: time, ticker, open, high, low, close, volume

Raises:
    ValueError: If neither phase, ticker nor tickers is provided.

**`get_training_data`**
```python
def get_training_data(tickers: Optional[List[str]] = None, phase: Optional[str] = None, years_back: Optional[int] = None, align_dates: bool = True) -> pd.DataFrame
```
> Get training/tuning data (all data up to and including 2024-12-31).

CRITICAL: This function ensures NO data after 2024-12-31 is included.

Args:
    tickers: List of ticker symbols. Defaults to FULL_TICKERS if phase not set.
    phase: 'limited' or 'full'. Sets tickers and default years_back from config.
    years_back: Override default years_back.
    align_dates: If True, only return dates where ALL tickers have data.

Returns:
    pd.DataFrame: Training OHLCV data.

**`get_trading_data`**
```python
def get_trading_data(tickers: Optional[List[str]] = None, align_dates: bool = True) -> pd.DataFrame
```
> Get trading simulation data (all data from start of 2025 onwards).

CRITICAL: This function ensures ONLY data from 2025-Jan-01 onwards is returned,
which should be used for backtesting and performance reporting.

Args:
    tickers: List of ticker symbols. Defaults to FULL_TICKERS.
    align_dates: If True, only return dates where ALL tickers have data.

Returns:
    pd.DataFrame: Trading OHLCV data (2025 onwards).

Example:
    >>> # Trading data for backtesting
    >>> trade_df = get_trading_data(FULL_TICKERS)
    >>> trade_df['time'].min()  # Should be >= 2025-Jan-01

**`get_ohlcv`**
```python
def get_ohlcv(ticker: str, start_date: Optional[str] = None, end_date: Optional[str] = None) -> pd.DataFrame
```
> Convenience alias for get_data() - get OHLCV data for a single ticker.

Args:
    ticker: Stock ticker symbol.
    start_date: Optional start date.
    end_date: Optional end date.

Returns:
    pd.DataFrame: OHLCV data for the specified ticker.

**`simicx_test_data_loader`**
```python
def simicx_test_data_loader()
```
> Test function for data_loader module.

Verifies:
1. Database connectivity
2. Ticker availability
3. Date range queries
4. Temporal split integrity (training ≤ 2024, trading ≥ 2025)
5. Date alignment across tickers

---

### `simicx/trading_sim.py`

> **Import**: `from simicx.trading_sim import ...`

> 
SimicX Trading Simulation Module

Author: SimicX
Copyright: SimicX 2024
License: SimicX XTT

Comprehensive backtesting engine for trading strategies with realistic fee modeling,
position tracking, constraint validation, and performance metrics.

Usage:
    from alpha_stream.tools.trading_sim import trading_sim
    
    pnl, pnl_details = trading_sim(
        trading_sheet=trading_df,
        initial_capital=1_000_000.0
    )


**class `Position`**
```python
class Position:
```
> Represents a position in a single asset with FIFO (First-In-First-Out) cost basis tracking.

This class manages both long and short positions for a single security ticker,
tracking individual lots for accurate cost basis and P&L calculations.

Position Types:
    - **Long positions**: positive quantity (bought stock, expecting price increase)
    - **Short positions**: negative quantity (borrowed and sold stock, expecting price decrease)

FIFO Accounting:
    When selling/covering positions, the oldest lots are consumed first. This provides
    accurate cost basis tracking for tax purposes and precise realized P&L calculations.

Attributes:
    ticker: The asset ticker (e.g., 'AAPL', 'DIA')
    lots: List of (quantity, price_per_share) tuples. Each tuple represents a lot:
          - quantity > 0 for long lots (shares owned)
          - quantity < 0 for short lots (shares owed)
          - price is the cost basis per share (including commission for buys)

Example:
    >>> # Create a new position and add lots
    >>> pos = Position(ticker='AAPL')
    >>> pos.add(100, 150.0)  # Buy 100 shares at $150
    >>> pos.add(50, 155.0)   # Buy 50 more at $155
    >>> 
    >>> # Check position state
    >>> pos.quantity  # Total shares: 150
    150.0
    >>> pos.avg_cost  # Weighted average: (100*150 + 50*155) / 150 = 151.67
    151.66666666666666
    >>> pos.market_value  # Total cost basis: 100*150 + 50*155 = 22750
    22750.0
    >>> 
    >>> # Sell using FIFO - removes from oldest lot first
    >>> removed_qty, cost_basis = pos.remove(75)  # Sell 75 shares
    >>> removed_qty  # Actually removed
    75.0
    >>> cost_basis  # Cost basis of sold shares (75 * $150 from first lot)
    11250.0
    >>> pos.lots  # Remaining: 25 shares at $150, 50 shares at $155
    [(25, 150.0), (50, 155.0)]
    
    >>> # Short position example
    >>> short_pos = Position(ticker='TSLA')
    >>> short_pos.add(-100, 200.0)  # Short 100 shares at $200 (net proceeds per share)
    >>> short_pos.quantity  # Negative = owe shares
    -100

**`Position.quantity`**
```python
def quantity(self) -> float
```
> Total quantity held across all lots.

Returns:
    float: Sum of all lot quantities.
           Positive for net long position (own shares).
           Negative for net short position (owe shares).
           Zero if no position or balanced.

Example:
    >>> pos = Position(ticker='AAPL')
    >>> pos.add(100, 150.0)  # Long 100
    >>> pos.add(-30, 155.0)  # Short 30 (partially close)
    >>> pos.quantity
    70.0

**`Position.avg_cost`**
```python
def avg_cost(self) -> float
```
> Weighted average cost basis per share across all lots.

Calculates the volume-weighted average price of all open lots.
For long positions, this represents the average purchase price.
For short positions, this represents the average sale price (proceeds received).

Returns:
    float: Average cost per share. Returns 0.0 if no position held.

Formula:
    avg_cost = Σ(quantity_i × price_i) / Σ(quantity_i)

Example:
    >>> pos = Position(ticker='AAPL')
    >>> pos.add(100, 150.0)  # 100 × $150 = $15,000
    >>> pos.add(50, 160.0)   # 50 × $160 = $8,000
    >>> pos.avg_cost  # ($15,000 + $8,000) / 150 = $153.33
    153.33333333333334
    
    >>> # With no position
    >>> empty_pos = Position(ticker='MSFT')
    >>> empty_pos.avg_cost
    0.0

**`Position.market_value`**
```python
def market_value(self) -> float
```
> Total cost basis of the position (quantity × cost per share for each lot).

This represents the total capital invested in the position. For unrealized
P&L calculation, compare this with `quantity × current_market_price`.

Returns:
    float: Sum of (quantity × price) for all lots.
           Positive for long positions (capital deployed).
           Negative for short positions (proceeds received).

Note:
    This is NOT the current market value. Use with current prices:
    `unrealized_pnl = (quantity × current_price) - market_value`

Example:
    >>> pos = Position(ticker='AAPL')
    >>> pos.add(100, 150.0)  # Cost: $15,000
    >>> pos.add(50, 160.0)   # Cost: $8,000
    >>> pos.market_value     # Total cost basis: $23,000
    23000.0
    
    >>> # Calculate unrealized P&L if current price is $170
    >>> current_price = 170.0
    >>> unrealized_pnl = (pos.quantity * current_price) - pos.market_value
    >>> unrealized_pnl  # 150 × $170 - $23,000 = $2,500
    2500.0

**`Position.add`**
```python
def add(self, quantity: float, price_per_share: float) -> None
```
> Add shares to this position as a new lot.

Creates a new lot entry in the position's lot list. Does NOT merge with
existing lots to maintain accurate FIFO tracking.

Position Direction:
    - quantity > 0: Adding long position (buying shares)
    - quantity < 0: Adding short position (shorting shares)

Args:
    quantity: Number of shares to add. Can be positive (long) or negative (short).
             Zero quantity is ignored (no lot created).
    price_per_share: Cost basis per share, should INCLUDE commission for accuracy.
                    For buys: (execution_price × quantity + commission) / quantity
                    For shorts: net_proceeds / quantity (after commission)

Returns:
    None. Modifies the position in-place.

Example:
    >>> pos = Position(ticker='AAPL')
    >>> 
    >>> # Add long position (100 shares at $150.15 including commission)
    >>> pos.add(100, 150.15)
    >>> pos.lots
    [(100, 150.15)]
    >>> 
    >>> # Add another lot at different price
    >>> pos.add(50, 155.0)
    >>> pos.lots  # Two separate lots maintained
    [(100, 150.15), (50, 155.0)]
    >>> 
    >>> # Add short position
    >>> short_pos = Position(ticker='TSLA')
    >>> short_pos.add(-100, 200.0)  # Short 100 at $200/share net proceeds
    >>> short_pos.quantity
    -100
    
Note:
    - Each call creates a new lot, even if price matches existing lots
    - Zero quantity is silently ignored (useful for conditional adds)
    - For accurate P&L, include commission in price_per_share

**`Position.remove`**
```python
def remove(self, quantity: float, is_short_covering: bool = False) -> Tuple[float, float]
```
> Remove shares from position using FIFO (First-In-First-Out) accounting.

Consumes lots in chronological order (oldest first) until the requested
quantity is removed. Handles partial lot consumption correctly.

FIFO Logic:
    1. Start with the oldest lot (first in the list)
    2. If lot quantity ≤ remaining to remove: consume entire lot
    3. If lot quantity > remaining: consume partial lot, update lot size
    4. Repeat until requested quantity is removed or no lots remain

Args:
    quantity: Number of shares to remove (always pass a POSITIVE value).
             The method handles both long and short position removal internally.
    is_short_covering: Optional flag indicating if this remove is for covering
                      a short position. Currently used for documentation purposes
                      but may affect future logic extensions.

Returns:
    Tuple[float, float]: A tuple containing:
        - actual_quantity_removed: How many shares were actually removed.
          May be less than requested if position is smaller.
        - cost_basis: Total cost basis of removed shares (quantity × price
          summed across consumed lots). For short positions, this is negative
          (representing proceeds received).

Example:
    >>> pos = Position(ticker='AAPL')
    >>> pos.add(100, 150.0)  # Lot 1: 100 @ $150
    >>> pos.add(50, 160.0)   # Lot 2: 50 @ $160
    >>> 
    >>> # Remove 75 shares (FIFO takes from oldest lot first)
    >>> removed_qty, cost_basis = pos.remove(75)
    >>> removed_qty
    75.0
    >>> cost_basis  # 75 × $150 from first lot
    11250.0
    >>> pos.lots  # First lot reduced, second untouched
    [(25, 150.0), (50, 160.0)]
    >>> 
    >>> # Remove remaining 25 from first lot + 30 from second
    >>> removed_qty, cost_basis = pos.remove(55)
    >>> cost_basis  # (25 × $150) + (30 × $160) = 3750 + 4800 = 8550
    8550.0
    >>> pos.lots  # 20 shares remaining from second lot
    [(20, 160.0)]
    >>> 
    >>> # Try to remove more than available
    >>> removed_qty, cost_basis = pos.remove(50)
    >>> removed_qty  # Only 20 available
    20.0
    >>> pos.lots  # Position fully closed
    []
    
    >>> # Edge case: remove from empty position
    >>> empty_pos = Position(ticker='MSFT')
    >>> empty_pos.remove(100)
    (0.0, 0.0)

Note:
    - For short positions (negative lot quantities), cost_basis represents
      the proceeds received when the short was opened (negative value).
    - The function gracefully handles partial fills when position is smaller
      than requested quantity.
    - Zero or negative quantity returns (0.0, 0.0) immediately.

**class `Portfolio`**
```python
class Portfolio:
```
> Portfolio state tracking with cash and positions.

Manages the overall portfolio state including cash balance and all open positions
(both long and short). Provides methods to calculate total portfolio value and
track holdings across multiple assets.

Attributes:
    cash: Current cash balance in the portfolio
    positions: Dictionary mapping ticker -> Position for all active positions

Example:
    >>> portfolio = Portfolio(cash=100_000.0)
    >>> # Buy 100 shares of AAPL at $150
    >>> pos = portfolio.get_position('AAPL')
    >>> pos.add(100, 150.0)
    >>> portfolio.cash -= 100 * 150.0
    >>> 
    >>> # Check portfolio value
    >>> prices = {'AAPL': 155.0}
    >>> total_value = portfolio.get_total_value(prices)
    >>> print(f"Portfolio value: ${total_value:,.2f}")  # Cash + holdings

**`Portfolio.get_position`**
```python
def get_position(self, ticker: str) -> Position
```
> Get or create position for a given ticker.

If the ticker doesn't exist in the portfolio, a new empty Position
is created and added to the portfolio.

Args:
    ticker: Asset ticker (e.g., 'AAPL', 'DIA')
    
Returns:
    Position object for the specified ticker

**`Portfolio.get_holdings_value`**
```python
def get_holdings_value(self, prices: Dict[str, float]) -> float
```
> Calculate total market value of all holdings at current prices.

For long positions (quantity > 0): positive value (asset)
For short positions (quantity < 0): negative value (liability)

Args:
    prices: Dictionary mapping ticker -> current market price

Returns:
    Total market value of all holdings. Positive for net long positions,
    negative for net short positions.
    
Example:
    >>> portfolio = Portfolio(cash=50_000)
    >>> # Long 100 AAPL, Short 50 TSLA
    >>> portfolio.get_position('AAPL').add(100, 150.0)
    >>> portfolio.get_position('TSLA').add(-50, 200.0)  # Short
    >>> prices = {'AAPL': 155.0, 'TSLA': 195.0}
    >>> holdings = portfolio.get_holdings_value(prices)
    >>> # = (100 * 155) + (-50 * 195) = 15,500 - 9,750 = 5,750

**`Portfolio.get_total_value`**
```python
def get_total_value(self, prices: Dict[str, float]) -> float
```
> Calculate total portfolio value (cash + holdings).

This represents the liquidation value of the portfolio if all positions
were closed at the given prices.

Args:
    prices: Dictionary mapping ticker -> current market price
    
Returns:
    Total portfolio value = cash + holdings_value
    
Note:
    For portfolios with short positions, holdings_value may be negative,
    representing the liability from short positions.

**`validate_trading_sheet`**
```python
def validate_trading_sheet(trading_sheet: pd.DataFrame) -> pd.DataFrame
```
> Validate and normalize trading sheet input.

Performs comprehensive validation and normalization of trading signals:
- Normalizes column names to lowercase
- Validates required columns are present
- Ensures action values are 'buy' or 'sell'
- Converts time to datetime format
- Validates numeric columns (quantity, price)
- Removes invalid rows with warnings
- Sorts by time chronologically

Args:
    trading_sheet: DataFrame with trade instructions containing columns:
        - time: Trading timestamp (str or datetime)
        - ticker: Asset ticker symbol (str)
        - action: 'buy' or 'sell' (case-insensitive)
        - quantity: Trade quantity (numeric)
        - price: Target execution price (numeric)
    
Returns:
    Validated DataFrame with normalized column names, sorted by time,
    with only valid rows retained
    
Raises:
    ValueError: If required columns are missing or action values are invalid
    
Warnings:
    Issues warnings when removing rows with invalid quantity/price values
    
Example:
    >>> import pandas as pd
    >>> # Valid input
    >>> trades = pd.DataFrame({
    ...     'TIME': ['2024-01-02 09:30:00', '2024-01-02 10:00:00'],
    ...     'TICKER': ['AAPL', 'MSFT'],
    ...     'Action': ['BUY', 'SELL'],  # Case-insensitive
    ...     'Quantity': [100, 50],
    ...     'Price': [150.50, 380.25]
    ... })
    >>> validated = validate_trading_sheet(trades)
    >>> validated.columns.tolist()
    ['time', 'ticker', 'action', 'quantity', 'price']
    
    >>> # Invalid input - missing column
    >>> bad_trades = pd.DataFrame({'time': ['2024-01-02'], 'ticker': ['AAPL']})
    >>> validate_trading_sheet(bad_trades)  # Raises ValueError
    
    >>> # Invalid input - bad action value
    >>> bad_trades = pd.DataFrame({
    ...     'time': ['2024-01-02'], 'ticker': ['AAPL'],
    ...     'action': ['HOLD'], 'quantity': [100], 'price': [150]
    ... })
    >>> validate_trading_sheet(bad_trades)  # Raises ValueError
    
Note:
    - Column names are case-insensitive and trimmed of whitespace
    - Empty DataFrames return an empty DataFrame with correct columns
    - Rows with NaN quantity or price are removed with a warning
    - All trades are sorted chronologically for proper execution order

**`calculate_execution_price`**
```python
def calculate_execution_price(target_price: float, action: str, slippage_rate: float = 0.0005, spread_rate: float = 0.0001) -> float
```
> Calculate realistic execution price with slippage and bid-ask spread.

Models the market impact of executing a trade by adjusting the target price
for realistic market conditions. Both slippage and spread work against the trader.

Cost Components:
    **Slippage**: The difference between expected and actual execution price due to
    market movement, order size impact, or latency. Always works against you.
    
    **Spread**: The difference between bid and ask prices. Buyers pay the ask (higher),
    sellers receive the bid (lower). The `spread_rate` represents half the spread.

Formulas:
    - Buy:  execution_price = target_price × (1 + slippage_rate + spread_rate)
    - Sell: execution_price = target_price × (1 - slippage_rate - spread_rate)

Args:
    target_price: The target/signal price from your trading strategy.
                 This is typically the close price or a calculated entry price.
    action: Trade direction - 'buy' or 'sell' (case-sensitive).
    slippage_rate: Slippage as a fraction of price. Default 0.0005 (0.05% or 5 bps).
                  Larger orders or less liquid assets typically have higher slippage.
    spread_rate: Half-spread as a fraction of price. Default 0.0001 (0.01% or 1 bp).
                Represents half of the bid-ask spread. Full spread = 2 × spread_rate.

Returns:
    float: Adjusted execution price after accounting for slippage and spread.

Example:
    >>> # Buying at $100 with default rates
    >>> calculate_execution_price(100.0, 'buy')
    100.06  # = 100 × (1 + 0.0005 + 0.0001)
    
    >>> # Selling at $100 with default rates  
    >>> calculate_execution_price(100.0, 'sell')
    99.94  # = 100 × (1 - 0.0005 - 0.0001)
    
    >>> # High-impact trade with larger slippage
    >>> calculate_execution_price(50.0, 'buy', slippage_rate=0.002, spread_rate=0.001)
    50.15  # = 50 × (1 + 0.002 + 0.001) = 50 × 1.003
    
    >>> # Calculate round-trip cost (buy then sell same price)
    >>> buy_price = calculate_execution_price(100.0, 'buy')
    >>> sell_price = calculate_execution_price(100.0, 'sell')
    >>> round_trip_cost = buy_price - sell_price  # $0.12 per share
    >>> round_trip_cost_pct = (round_trip_cost / 100.0) * 100  # 0.12%

Note:
    - Default values represent typical costs for liquid US equities
    - Crypto, forex, and less liquid assets often have higher rates
    - These costs are IN ADDITION to commissions
    - For limit orders with guaranteed fills, you may set both rates to 0

**`calculate_performance_metrics`**
```python
def calculate_performance_metrics(returns: pd.Series, risk_free_rate: float = 0.02) -> Dict[str, float]
```
> Calculate comprehensive performance metrics for trading strategy evaluation.

Computes a wide range of industry-standard metrics to assess strategy performance,
risk characteristics, and return quality. All calculations assume 252 trading days
per year for annualization.

Metric Categories:
    **Return Metrics**:
    - `total_return`: Cumulative return over the entire period
    - `annualized_return`: Geometric mean annual return
    - `avg_daily_return`: Arithmetic mean of daily returns
    - `volatility`: Annualized standard deviation of returns
    
    **Risk-Adjusted Metrics**:
    - `sharpe_ratio`: Excess return per unit of total risk
    - `sortino_ratio`: Excess return per unit of downside risk
    - `calmar_ratio`: Annualized return / max drawdown
    
    **Drawdown Analysis**:
    - `max_drawdown`: Largest peak-to-trough decline (negative value)
    - `avg_drawdown`: Average drawdown when in drawdown
    - `max_drawdown_duration`: Longest drawdown period in days
    
    **Win/Loss Statistics**:
    - `win_rate`: Percentage of positive return days
    - `profit_factor`: Gross profit / gross loss
    - `payoff_ratio`: Average win / average loss (absolute)
    
    **Distribution Characteristics**:
    - `skewness`: Return distribution asymmetry (positive = right tail)
    - `kurtosis`: Return distribution tail thickness (>3 = fat tails)
    - `var_95`: 5th percentile daily return (Value at Risk)
    - `cvar_95`: Mean of returns below VaR (Conditional VaR / Expected Shortfall)

Args:
    returns: pandas Series of daily returns in decimal format.
            Example: 0.01 represents a +1% daily return, -0.02 represents a -2% return.
            Must be simple returns, not log returns.
    risk_free_rate: Annual risk-free rate in decimal format.
                   Default 0.02 represents 2% annual risk-free rate.
                   Used for Sharpe and Sortino ratio calculations.

Returns:
    Dict[str, float]: Dictionary containing all computed metrics.
    Returns empty dict if returns series is empty or has fewer than 2 values.

Example:
    >>> import pandas as pd
    >>> import numpy as np
    >>> 
    >>> # Generate sample returns (252 trading days)
    >>> np.random.seed(42)
    >>> daily_returns = pd.Series(np.random.normal(0.0005, 0.02, 252))
    >>> 
    >>> metrics = calculate_performance_metrics(daily_returns)
    >>> 
    >>> # Access individual metrics
    >>> print(f"Total Return: {metrics['total_return']*100:.2f}%")
    >>> print(f"Sharpe Ratio: {metrics['sharpe_ratio']:.2f}")
    >>> print(f"Max Drawdown: {metrics['max_drawdown']*100:.2f}%")
    >>> print(f"Win Rate: {metrics['win_rate']*100:.1f}%")
    
    >>> # Using with trading_sim results
    >>> pnl, details = trading_sim(trading_sheet=trades, ohlcv_path='data.csv')
    >>> if 'metrics' in details.attrs:
    ...     metrics = details.attrs['metrics']
    ...     print(f"Strategy Sharpe: {metrics['sharpe_ratio']:.2f}")

Formulas:
    - Sharpe Ratio: (E[R] - Rf) × √252 / (σ × √252)
    - Sortino Ratio: (E[R] - Rf) × 252 / (σ_downside × √252)
    - Max Drawdown: min((cumulative - running_max) / running_max)
    - VaR 95%: 5th percentile of return distribution
    - CVaR 95%: E[R | R ≤ VaR_95]

Note:
    - Returns 999.0 for infinite ratios (e.g., Sortino with no downside days)
    - Metrics are computed on non-NaN values only
    - Assumes continuous daily data (gaps may affect drawdown duration)

**`convert_signals_to_trades`**
```python
def convert_signals_to_trades(signals: pd.DataFrame, signal_type: str, ohlcv_df: pd.DataFrame, initial_capital: float = 1000000.0, max_position_pct: float = 0.25) -> pd.DataFrame
```
> Convert raw alpha signals into a trading sheet.

Args:
    signals: DataFrame with [time, ticker, signal]
    signal_type: 'TARGET_WEIGHT', 'ALPHA_SCORE', or 'BINARY'
    ohlcv_df: Market data for price lookup
    initial_capital: For calculating quantities
    max_position_pct: Max allocation per asset
    
Returns:
    DataFrame trading_sheet [time, ticker, action, quantity, price]

**`trading_sim`**
```python
def trading_sim(trading_sheet: Optional[pd.DataFrame] = None, signals: Optional[pd.DataFrame] = None, signal_type: Optional[str] = None, initial_capital: float = 1000000.0, commission_rate: float = 0.001, slippage_rate: float = 0.0005, spread_rate: float = 0.0001, min_trade_value: float = 100.0, allow_short: bool = False, allow_leverage: bool = False, max_position_pct: float = 0.25, risk_free_rate: float = 0.02) -> Tuple[float, pd.DataFrame]
```
> Comprehensive trading simulation/backtesting engine.

Can accept EITHER:
1. trading_sheet: Explicit buy/sell orders
2. signals + signal_type: Raw signals to be converted to trades

Args:
    trading_sheet: DataFrame with columns [time, ticker, action, quantity, price(optional)]
    signals: DataFrame with columns [time, ticker, signal]
    signal_type: 'TARGET_WEIGHT', 'ALPHA_SCORE', 'BINARY'
    initial_capital: Starting cash (default $1,000,000)
    commission_rate: Commission as fraction of trade value (default 0.1%)
    slippage_rate: Slippage as fraction of price (default 0.05%)
    spread_rate: Half-spread as fraction of price (default 0.01%)
    min_trade_value: Minimum trade value threshold (default $100)
    allow_short: Allow short selling (default False)
    allow_leverage: Allow leverage/margin (default False)
    max_position_pct: Max single position as pct of portfolio (default 25%)
    risk_free_rate: Annual risk-free rate for metrics (default 2%)
    
Returns:
    Tuple of:
    - pnl (float): Final portfolio P&L (final_value - initial_capital)
    - pnl_details (pd.DataFrame): Detailed trade-by-trade breakdown
        
Raises:
    ValueError: If inputs are invalid
    FileNotFoundError: If OHLCV file not found

**`generate_performance_report`**
```python
def generate_performance_report(pnl_details: pd.DataFrame) -> str
```
> Generate a comprehensive, formatted performance report from trading simulation results.

Creates a professional text-based report suitable for logging, display, or export.
The report includes capital summary, return metrics, risk-adjusted ratios,
drawdown analysis, win/loss statistics, and trade execution summary.

Report Sections:
    **CAPITAL SUMMARY**: Initial capital, final value, total P&L, and return %
    
    **RETURN METRICS**: Annualized return, volatility, average daily return
    
    **RISK-ADJUSTED METRICS**: Sharpe, Sortino, and Calmar ratios
    
    **DRAWDOWN ANALYSIS**: Maximum drawdown, average drawdown, max duration
    
    **WIN/LOSS STATISTICS**: Win rate, profit factor, payoff ratio
    
    **RISK METRICS**: VaR 95%, CVaR 95%, skewness, kurtosis
    
    **TRADE SUMMARY**: Total trades, executed/rejected counts, commissions, realized P&L

Args:
    pnl_details: DataFrame returned by `trading_sim()` function. Must have `.attrs`
                dictionary containing 'metrics', 'initial_capital', 'final_value',
                and 'total_pnl' keys. These are automatically attached by trading_sim.

Returns:
    str: A multi-line formatted string containing the complete performance report.
         Returns "No performance metrics available." if pnl_details lacks metrics.

Example:
    >>> import pandas as pd
    >>> 
    >>> # Create trading signals
    >>> trades = pd.DataFrame({
    ...     'time': ['2024-01-02', '2024-01-15', '2024-02-01'],
    ...     'ticker': ['AAPL', 'AAPL', 'AAPL'],
    ...     'action': ['buy', 'sell', 'buy'],
    ...     'quantity': [100, 100, 50],
    ...     'price': [150.0, 155.0, 152.0]
    ... })
    >>> 
    >>> # Run simulation and generate report
    >>> pnl, details = trading_sim(
    ...     trading_sheet=trades,
    ...     ohlcv_path='market_data/ohlcv.csv',
    ...     initial_capital=100_000
    ... )
    >>> 
    >>> # Generate and print report
    >>> report = generate_performance_report(details)
    >>> print(report)
    ================================================================================
                         TRADING SIMULATION REPORT
    ================================================================================
    
    CAPITAL SUMMARY
    ---------------
      Initial Capital:    $     100,000.00
      Final Value:        $     100,450.00
      ...
    
    >>> # Save report to file
    >>> with open('backtest_report.txt', 'w') as f:
    ...     f.write(report)

Note:
    - Requires pnl_details to have metrics attached via .attrs dictionary
    - All percentages are displayed with proper formatting
    - Currency values use comma separators and 2 decimal places
    - Infinite ratios (e.g., from no losing trades) display as 999.000

**`simicx_test_trading_sim`**
```python
def simicx_test_trading_sim()
```
---

### `tune.py`

> **Import**: `from tune import ...`

> 
Hyperparameter Tuning and Agent Selection Module for DRL Trading System.

This module provides functionality to:
1. Load training data based on phase (limited/full ticker set)
2. Compute global statistics (mean returns, covariance matrix, turbulence threshold)
3. Train ensemble DRL agents (PPO, A2C, DDPG) on training data
4. Validate agents on held-out data and compute Sharpe ratios
5. Select best agent and save weights/parameters for production use

The training process uses an actor-critic approach with advantage estimation,
following PPO-style updates for all agent types.


**`compute_returns`**
```python
def compute_returns(ohlcv_df: pd.DataFrame, tickers: List[str]) -> pd.DataFrame
```
> Compute daily returns for each ticker from OHLCV data.

Pivots the close prices by ticker and computes percentage changes.

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, open, high, low, close, volume]
    tickers: List of ticker symbols (must match tickers in ohlcv_df)
    
Returns:
    pd.DataFrame: Returns DataFrame with time index and ticker columns.
                 First row is NaN due to pct_change, so it's dropped.
    
Example:
    >>> df = pd.DataFrame({
    ...     'time': pd.date_range('2024-01-01', periods=5).repeat(2),
    ...     'ticker': ['AAPL', 'MSFT'] * 5,
    ...     'close': [100, 200, 102, 204, 104, 208, 106, 212, 108, 216]
    ... })
    >>> returns = compute_returns(df, ['AAPL', 'MSFT'])
    >>> returns.shape[1]  # 2 tickers
    2
    >>> len(returns)  # 4 rows (5 - 1 for pct_change)
    4

**`compute_global_statistics`**
```python
def compute_global_statistics(ohlcv_df: pd.DataFrame, tickers: List[str]) -> Tuple[np.ndarray, np.ndarray, float]
```
> Compute global mean, covariance of returns, and turbulence threshold.

Calculates statistics over the ENTIRE training period for use in:
- Turbulence parameter storage (mu, sigma)
- Risk management threshold (99th percentile)

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, close, ...]
    tickers: List of ticker symbols (must be 30)
    
Returns:
    Tuple of:
        - mu: Mean returns array of shape (30,) as float64
        - sigma: Covariance matrix of shape (30, 30) as float64
        - threshold: 99th percentile turbulence threshold
        
Example:
    >>> mu, sigma, threshold = compute_global_statistics(ohlcv_df, tickers)
    >>> mu.shape
    (30,)
    >>> sigma.shape
    (30, 30)
    >>> threshold > 0
    True

**`split_train_validation`**
```python
def split_train_validation(ohlcv_df: pd.DataFrame, validation_months: int = 3) -> Tuple[pd.DataFrame, pd.DataFrame]
```
> Split data into training and validation sets temporally.

Training: start to (end - validation_months)
Validation: last validation_months

Args:
    ohlcv_df: OHLCV DataFrame with 'time' column
    validation_months: Number of months for validation (default: 3)
    
Returns:
    Tuple of (train_df, val_df) DataFrames
    
Example:
    >>> train_df, val_df = split_train_validation(ohlcv_df, validation_months=3)
    >>> train_df['time'].max() < val_df['time'].min()
    True

**`get_prices_for_date`**
```python
def get_prices_for_date(ohlcv_df: pd.DataFrame, date: pd.Timestamp, tickers: List[str]) -> np.ndarray
```
> Get close prices for all tickers on a specific date.

Args:
    ohlcv_df: OHLCV DataFrame with columns [time, ticker, close, ...]
    date: Target date to get prices for
    tickers: List of ticker symbols (30 tickers)
    
Returns:
    np.ndarray: Prices array of shape (30,) as float32

**`get_features_for_date`**
```python
def get_features_for_date(features_df: pd.DataFrame, date: pd.Timestamp, tickers: List[str]) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]
```
> Extract technical indicator features for a specific date.

Args:
    features_df: Features DataFrame from calc_features, indexed by time
    date: Target date to get features for
    tickers: List of ticker symbols (30 tickers)
    
Returns:
    Tuple of (macd, rsi, cci, adx) arrays, each of shape (30,) as float32
    Returns default values if date not found.

**`compute_portfolio_value`**
```python
def compute_portfolio_value(balance: float, holdings: np.ndarray, prices: np.ndarray) -> float
```
> Compute total portfolio value (cash + holdings).

Args:
    balance: Cash balance
    holdings: Holdings array of shape (30,)
    prices: Prices array of shape (30,)
    
Returns:
    Total portfolio value as float

**`execute_actions`**
```python
def execute_actions(actions: np.ndarray, balance: float, holdings: np.ndarray, prices: np.ndarray, h_max: int = H_MAX) -> Tuple[float, np.ndarray]
```
> Execute trading actions and update portfolio state.

Actions in [-1, 1] are scaled by h_max to get share quantities.
Positive actions = buy, Negative actions = sell.

Trades are constrained by:
- Available cash (for buys)
- Available holdings (for sells)

Args:
    actions: Action array of shape (30,) in range [-1, 1]
    balance: Current cash balance
    holdings: Current holdings array of shape (30,)
    prices: Current prices array of shape (30,)
    h_max: Maximum shares per trade (default: 100)
    
Returns:
    Tuple of (new_balance, new_holdings)
    
Example:
    >>> actions = np.array([0.5, -0.3] + [0.0]*28)  # buy, sell, hold rest
    >>> balance = 100000.0
    >>> holdings = np.zeros(30, dtype=np.float32)
    >>> holdings[1] = 100  # Have 100 shares to sell
    >>> prices = np.ones(30, dtype=np.float32) * 100
    >>> new_bal, new_hold = execute_actions(actions, balance, holdings, prices)
    >>> new_hold[0] > 0  # Bought first stock
    True
    >>> new_hold[1] < 100  # Sold second stock
    True

**`train_agent`**
```python
def train_agent(agent: torch.nn.Module, optimizer: torch.optim.Optimizer, train_df: pd.DataFrame, features_df: pd.DataFrame, tickers: List[str], device: torch.device, h_max: int = H_MAX) -> torch.nn.Module
```
> Train a single agent on the training data using actor-critic updates.

Uses PPO-style training with:
- Generalized Advantage Estimation (GAE) for advantage computation
- Clipped surrogate objective for policy updates
- Value function loss for critic updates

Args:
    agent: Agent to train (PPOAgent, A2CAgent, or DDPGAgent)
    optimizer: PyTorch optimizer for agent parameters
    train_df: Training OHLCV DataFrame
    features_df: Features DataFrame from calc_features
    tickers: List of ticker symbols (30 tickers)
    device: Computation device (cuda/mps/cpu)
    h_max: Maximum shares per trade (default: 100)
    
Returns:
    Trained agent (modified in-place, also returned for convenience)
    
Example:
    >>> agent = PPOAgent(device=device)
    >>> optimizer = torch.optim.Adam(agent.parameters(), lr=1e-4)
    >>> trained = train_agent(agent, optimizer, train_df, features_df, tickers, device)

**`validate_agent`**
```python
def validate_agent(agent: torch.nn.Module, val_df: pd.DataFrame, features_df: pd.DataFrame, tickers: List[str], device: torch.device, h_max: int = H_MAX) -> float
```
> Validate agent on held-out data and compute Sharpe ratio.

Runs the agent in inference mode (no training) through the validation
period and computes the annualized Sharpe ratio of daily returns.

Args:
    agent: Trained agent to validate
    val_df: Validation OHLCV DataFrame
    features_df: Features DataFrame from calc_features
    tickers: List of ticker symbols (30 tickers)
    device: Computation device
    h_max: Maximum shares per trade (default: 100)
    
Returns:
    Annualized Sharpe ratio (can be negative)
    
Example:
    >>> sharpe = validate_agent(agent, val_df, features_df, tickers, device)
    >>> isinstance(sharpe, float)
    True

**`tune`**
```python
def tune(phase: str = 'limited') -> Dict
```
> Main tuning function to train ensemble agents and select best one.

This function:
1. Loads configuration and training data based on phase
2. Computes global statistics (mean, covariance, turbulence threshold)
3. Splits data into training and validation sets
4. Trains PPO, A2C, and DDPG agents
5. Validates each agent and selects the one with highest Sharpe ratio
6. Saves best agent weights to 'best_agent.pth'
7. Saves parameters to 'best_params.json'

Args:
    phase: 'limited' or 'full' ticker set (default: 'limited')
    
Returns:
    Dict with keys:
        - agent_type: Best agent type ('ppo', 'a2c', or 'ddpg')
        - sharpe: Validation Sharpe ratio of best agent
        - params_path: Path to saved parameters JSON
        - model_path: Path to saved model weights
        
Example:
    >>> result = tune(phase='limited')
    >>> result['agent_type'] in ['ppo', 'a2c', 'ddpg']
    True
    >>> os.path.exists(result['model_path'])
    True

**`main`**
```python
def main()
```
> Entry point for tuning script with CLI argument parsing.

**`simicx_test_compute_returns`**
```python
def simicx_test_compute_returns()
```
> Test return computation from OHLCV data.

**`simicx_test_portfolio_operations`**
```python
def simicx_test_portfolio_operations()
```
> Test portfolio value computation and action execution.

**`simicx_test_integration_with_signal_gen`**
```python
def simicx_test_integration_with_signal_gen()
```
> Integration test exercising signal_gen module interfaces.

---

## Project Structure

```
coding/
├── docs/
│   └── full_doc.md (60116b)
├── simicx/
│   ├── alpha_config.json (469b)
│   ├── data_loader.py (17028b)
│   └── trading_sim.py (69193b)
├── main.py (20225b)
├── signal_gen.py (36494b)
├── simicx.research.db (1069056b)
└── tune.py (34103b)
```
